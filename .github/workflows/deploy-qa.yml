name: Deploy to QA

on:
  push:
    branches:
      - main
    paths:
      # Trigger on all changes except version files
      - 'apps/server/**'
      - 'packages/shared/**'
      - 'deploy/docker/**'
      - 'deploy/scripts/**'
      - 'apps/mobile/**'
      - 'package.json'
      - 'pnpm-lock.yaml'
      # Exclude version files (they trigger release.yml instead)
      - '!apps/mobile/app.json'
      - '!apps/mobile/android/app/build.gradle'

  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even without server changes'
        required: false
        default: 'false'

jobs:
  detect-version-bump:
    name: Detect version file changes
    runs-on: ubuntu-latest
    outputs:
      is_version_bump: ${{ steps.check.outputs.is_version_bump }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
      
      - name: Check if only version files changed
        id: check
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "is_version_bump=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get changed files from last two commits
          CHANGED_FILES=$(git diff --name-only HEAD~1..HEAD)
          
          # Version files that trigger release.yml instead
          VERSION_FILES="package.json apps/mobile/app.json apps/mobile/android/app/build.gradle"
          
          # Check if all changed files are version files
          IS_VERSION_ONLY=true
          while IFS= read -r file; do
            if [ -z "$file" ]; then continue; fi
            if ! echo "$VERSION_FILES" | grep -q "$file"; then
              IS_VERSION_ONLY=false
              break
            fi
          done <<< "$CHANGED_FILES"
          
          if [ "$IS_VERSION_ONLY" = true ] && [ ! -z "$CHANGED_FILES" ]; then
            echo "is_version_bump=true" >> $GITHUB_OUTPUT
            echo "‚ÑπÔ∏è  Version file change detected. Skipping QA build (will trigger release.yml instead)."
          else
            echo "is_version_bump=false" >> $GITHUB_OUTPUT
          fi

  build-and-push:
    name: Build & Push Docker Images
    runs-on: ubuntu-latest
    needs: detect-version-bump
    if: ${{ needs.detect-version-bump.outputs.is_version_bump == 'false' }}
    permissions:
      contents: read
      packages: write
    
    outputs:
      image_tag: ${{ steps.meta.outputs.tags }}
      image_digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ghcr.io/${{ github.repository }}/server
          tags: |
            type=raw,value=qa
            type=sha,prefix=qa-
            type=ref,event=branch
      
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./deploy/docker/server/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            NODE_ENV=production
      
      - name: Output image details
        run: |
          echo "‚úÖ Image built and pushed successfully"
          echo "Tags: ${{ steps.meta.outputs.tags }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

  notify-homeserver:
    name: Notify Homeserver to Update
    needs: build-and-push
    runs-on: ubuntu-latest
    if: always() && needs.build-and-push.result == 'success'
    
    steps:
      - name: Trigger homeserver webhook
        env:
          WEBHOOK_URL: ${{ secrets.QA_WEBHOOK_URL }}
          WEBHOOK_SECRET: ${{ secrets.QA_WEBHOOK_SECRET }}
        run: |
          if [ -z "$WEBHOOK_URL" ]; then
            echo "‚ö†Ô∏è  QA_WEBHOOK_URL secret not set - skipping webhook"
            echo "‚ÑπÔ∏è  Set this in repository Settings ‚Üí Secrets ‚Üí Actions"
            echo "‚ÑπÔ∏è  Format: https://your-tunnel-url/deploy"
            exit 0
          fi
          
          # Create payload
          PAYLOAD=$(cat <<EOF
          {
            "event": "deploy",
            "repository": "${{ github.repository }}",
            "ref": "${{ github.ref }}",
            "sha": "${{ github.sha }}",
            "actor": "${{ github.actor }}",
            "image_tag": "ghcr.io/${{ github.repository }}/server:qa",
            "image_digest": "${{ needs.build-and-push.outputs.image_digest }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
          }
          EOF
          )
          
          # Calculate signature (if secret is set)
          if [ -n "$WEBHOOK_SECRET" ]; then
            SIGNATURE=$(echo -n "$PAYLOAD" | openssl dgst -sha256 -hmac "$WEBHOOK_SECRET" | sed 's/^.* //')
            SIGNATURE_HEADER="X-Hub-Signature-256: sha256=$SIGNATURE"
          else
            SIGNATURE_HEADER=""
            echo "‚ö†Ô∏è  QA_WEBHOOK_SECRET not set - webhook will not be authenticated"
          fi
          
          # Send webhook
          echo "üì§ Sending deployment webhook to homeserver..."
          HTTP_CODE=$(curl -s -o /tmp/webhook-response.txt -w "%{http_code}" \
            -X POST \
            -H "Content-Type: application/json" \
            -H "X-GitHub-Event: deployment" \
            -H "$SIGNATURE_HEADER" \
            -d "$PAYLOAD" \
            "$WEBHOOK_URL")
          
          if [ "$HTTP_CODE" -ge 200 ] && [ "$HTTP_CODE" -lt 300 ]; then
            echo "‚úÖ Webhook sent successfully (HTTP $HTTP_CODE)"
            cat /tmp/webhook-response.txt
          else
            echo "‚ùå Webhook failed (HTTP $HTTP_CODE)"
            cat /tmp/webhook-response.txt
            exit 1
          fi

  summary:
    name: Deployment Summary
    needs: [build-and-push, notify-homeserver]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Generate summary
        run: |
          echo "## üöÄ QA Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.build-and-push.result }}" == "success" ]; then
            echo "‚úÖ **Build & Push**: Success" >> $GITHUB_STEP_SUMMARY
            echo "- Image: \`ghcr.io/${{ github.repository }}/server:qa\`" >> $GITHUB_STEP_SUMMARY
            echo "- Digest: \`${{ needs.build-and-push.outputs.image_digest }}\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Build & Push**: Failed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.notify-homeserver.result }}" == "success" ]; then
            echo "‚úÖ **Homeserver Notification**: Sent" >> $GITHUB_STEP_SUMMARY
            echo "- Your QA environment should update automatically" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ needs.notify-homeserver.result }}" == "skipped" ]; then
            echo "‚è≠Ô∏è  **Homeserver Notification**: Skipped (webhook not configured)" >> $GITHUB_STEP_SUMMARY
            echo "- Set \`QA_WEBHOOK_URL\` secret to enable automatic updates" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Homeserver Notification**: Failed" >> $GITHUB_STEP_SUMMARY
            echo "- Check webhook configuration" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Wait for homeserver to pull and deploy (1-2 minutes)" >> $GITHUB_STEP_SUMMARY
          echo "2. Check QA health: \`curl http://localhost:3002/health\`" >> $GITHUB_STEP_SUMMARY
          echo "3. View logs: \`pnpm run docker:quality -- logs -f\`" >> $GITHUB_STEP_SUMMARY

  android-qa:
    name: Build Android APK (QA) via EAS
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' && inputs.build_android }}
    permissions:
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: npm

      - name: Setup Expo and EAS
        uses: expo/expo-github-action@v8
        with:
          eas-version: latest
          token: ${{ secrets.EXPO_TOKEN }}

      - name: Install dependencies
        run: npm ci

      - name: Build Android APK via EAS
        working-directory: apps/mobile
        run: eas build --platform android --non-interactive --output=./app-release.apk

      - name: Upload APK artifact
        uses: actions/upload-artifact@v4
        with:
          name: android-qa-apk
          path: apps/mobile/app-release.apk
          retention-days: 7
